<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Wandering Robot – Live Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f1220;
      --panel: #171a2b;
      --muted: #8a90b2;
      --text: #e9ecff;
      --accent: #7aa2ff;
      --ok: #2ecc71;
      --warn: #f39c12;
      --err: #e74c3c;
      --arrow-idle: #2b2f47;
      --arrow-active: #7aa2ff;
    }
    * { box-sizing: border-box }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 600px at 20% -10%, #19203c 0%, #0f1220 55%), var(--bg);
      color: var(--text);
    }
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 24px;
      border-bottom: 1px solid #232747;
      position: sticky;
      top: 0;
      backdrop-filter: blur(6px);
      background: rgba(15, 18, 32, 0.7);
      z-index: 10;
    }
    header h1 {
      margin: 0;
      font-size: 18px;
      letter-spacing: 0.3px;
    }
    header .pill {
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      background: #1e2342;
      color: var(--muted);
      border: 1px solid #2a2f57;
    }

    .container {
      padding: 20px 24px 40px;
      max-width: 1200px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 1.2fr 1fr;
      grid-template-areas:
        "top-cards top-cards"
        "viz sidebar"
        "logs controls";
      grid-gap: 20px;
    }

    /* Top status cards */
    .cards { grid-area: top-cards; display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; }
    .card {
      background: linear-gradient(180deg, #1b1f38 0%, #161a2f 100%);
      border: 1px solid #2a2f57;
      border-radius: 12px;
      padding: 16px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.03), 0 10px 24px rgba(0,0,0,0.2);
      min-height: 86px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .card .label { color: var(--muted); font-size: 12px; }
    .card .value { font-size: 24px; font-weight: 600; letter-spacing: 0.2px; }
    .badge { font-size: 11px; padding: 2px 8px; border-radius: 999px; border: 1px solid #2a2f57; color: var(--muted); }

    /* Visualization + Sidebar */
    .viz {
      grid-area: viz;
      background: linear-gradient(180deg, #171b33 0%, #151831 100%);
      border: 1px solid #2a2f57;
      border-radius: 12px;
      padding: 16px;
    }
    .viz h2, .sidebar h2, .panel h2 { margin: 0 0 12px; font-size: 14px; color: var(--muted); font-weight: 600; letter-spacing: 0.3px; }

    .viz-canvas {
      position: relative;
      width: 100%;
      aspect-ratio: 1.6 / 1; /* wide top-down viewport */
      background: radial-gradient(900px 400px at 50% -10%, rgba(122,162,255,0.06), transparent 60%);
      border-radius: 10px;
      border: 1px solid #2a2f57;
      overflow: hidden;
    }

    /* Robot diagram (SVG) */
    .svg-wrap { position: absolute; inset: 0; display: grid; place-items: center; }
    .arrow { transition: fill 160ms ease, opacity 160ms ease; fill: var(--arrow-idle); opacity: 0.8; }
    .arrow.active { fill: var(--arrow-active); opacity: 1; }
    .robot-body { fill: #121528; stroke: #3a4276; stroke-width: 2; }
    .wheel { fill: #0e1122; stroke: #2d335d; stroke-width: 2; }
    .sensor-cone { /* dynamic fill/stroke set via JS */ }
    .sensor-dot { fill: #7aa2ff; }

    /* Sidebar (explanation/state) */
    .sidebar {
      grid-area: sidebar;
      display: grid;
      grid-template-rows: auto auto 1fr;
      gap: 16px;
    }
    .panel {
      background: linear-gradient(180deg, #1b1f38 0%, #161a2f 100%);
      border: 1px solid #2a2f57;
      border-radius: 12px;
      padding: 14px 16px;
    }
    .explain { font-size: 14px; color: #cdd4ff; line-height: 1.4; }
    .kv { display: grid; grid-template-columns: 120px 1fr; gap: 6px 10px; font-size: 13px; color: #cdd4ff; }
    .kv .k { color: var(--muted); }

    /* Logs and Controls */
    .logs { grid-area: logs; }
    .controls { grid-area: controls; }

    .log-box {
      height: 240px;
      overflow: auto;
      padding: 12px;
      border-radius: 10px;
      border: 1px solid #2a2f57;
      background: #111428;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12.5px;
      line-height: 1.45;
      white-space: pre-wrap;
    }

    .btns { display: grid; gap: 10px; }
    .btn-row { display: flex; gap: 10px; align-items: center; }
    .btn-row.space-between { justify-content: space-between; }
    .btn-row.center { justify-content: center; }
    button {
      background: #1d2346;
      color: var(--text);
      border: 1px solid #2a2f57;
      padding: 10px 14px;
      transition: all 0.2s ease;
      border-radius: 10px;
      font-weight: 600;
      letter-spacing: 0.3px;
      cursor: pointer;
      transition: transform 120ms ease, background 160ms ease, border-color 160ms ease;
      width: 160px; /* consistent width across rows */
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    button:hover { background: #212858; border-color: #3a4276; transform: translateY(-1px); }
    button:active { transform: translateY(0); }
    .btn-accent { background: #2a356e; border-color: #4250a3; }
    .btn-danger { background: #4b1d2b; border-color: #a33f5a; }
    .btn-success { background: #1f3f30; border-color: #2e6f52; }

    /* Configuration Overrides */
    .config-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-bottom: 16px;
    }
    .config-group {
      background: rgba(10, 12, 25, 0.3);
      border: 1px solid #2a2f57;
      border-radius: 8px;
      padding: 12px;
    }
    .config-group h3 {
      margin: 0 0 12px 0;
      font-size: 13px;
      color: var(--muted);
      font-weight: 600;
      letter-spacing: 0.3px;
    }
    .control-group {
      margin-bottom: 10px;
    }
    .control-group:last-child {
      margin-bottom: 0;
    }
    .control-group label {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: #cdd4ff;
      margin-bottom: 4px;
    }
    .control-group input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: #1d2346;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
      margin: 8px 0;
    }
    
    .control-group input[type="range"].overridden {
      background: linear-gradient(90deg, #2a356e 0%, #2a356e var(--fill-percent, 0%), #1d2346 var(--fill-percent, 0%));
    }
    .control-group input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      transition: all 0.2s;
    }
    .control-group input[type="range"]:hover::-webkit-slider-thumb {
      transform: scale(1.2);
    }
    .status-message {
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 13px;
      margin-top: 8px;
      transition: all 0.3s ease;
    }
    .status-message.success {
      background: rgba(46, 204, 113, 0.15);
      color: #2ecc71;
      border: 1px solid rgba(46, 204, 113, 0.3);
    }
    .status-message.error {
      background: rgba(231, 76, 60, 0.15);
      color: #e74c3c;
      border: 1px solid rgba(231, 76, 60, 0.3);
    }

    @media (max-width: 980px) {
      .container {
        grid-template-columns: 1fr;
        grid-template-areas:
          "top-cards"
          "viz"
          "sidebar"
          "logs"
          "controls";
      }
      .cards { grid-template-columns: 1fr 1fr; }
      .config-grid { grid-template-columns: 1fr 1fr; }
    }
    
    @media (max-width: 600px) {
      .config-grid { grid-template-columns: 1fr; }
    }
  </style>
  </head>
  <body>
  <header>
    <h1>Wandering Robot • Live Dashboard</h1>
    <div class="pill" id="modePill">Mode: AUTO</div>
  </header>

  <main class="container">
    <!-- TOP CARDS -->
    <section class="cards">
      <div class="card">
        <div class="label">Distance</div>
        <div class="value" id="cardDistance">—</div>
        <span class="badge" id="distanceBadge">waiting…</span>
      </div>
      <div class="card">
        <div class="label">Motion</div>
        <div class="value" id="cardMotion">stop</div>
        <span class="badge" id="speedBadge">0.00</span>
      </div>
      <div class="card">
        <div class="label">Queue</div>
        <div class="value" id="cardQueue">0</div>
        <span class="badge" id="stuckBadge">stuck: no</span>
      </div>
      <div class="card">
        <div class="label">Log File</div>
        <div class="value" id="cardLog">runlog_YYYYMMDD_HHMMSS.csv</div>
        <span class="badge" id="uptimeBadge">uptime: —</span>
      </div>
    </section>

    <!-- VISUALIZATION -->
    <section class="viz">
      <h2>Top View</h2>
      <div style="font-size:12px; color: var(--muted); display:flex; gap:10px; align-items:center; margin-bottom:8px;">
        <label style="display:flex; align-items:center; gap:6px;">
          <input type="checkbox" id="dbgSim" /> Simulate distance
        </label>
        <input type="range" id="dbgRange" min="0" max="200" value="100" style="flex:1;" />
        <span id="dbgVal">100 cm</span>
      </div>
      <div class="viz-canvas">
        <div class="svg-wrap">
          <svg viewBox="0 0 600 360" width="100%" height="100%" aria-label="Robot top view">
            <!-- arrows -->
            <polygon id="arrowUp" class="arrow" points="300,45 285,70 315,70"/>
            <polygon id="arrowDown" class="arrow" points="300,315 285,290 315,290"/>
            <polygon id="arrowLeft" class="arrow" points="120,180 145,165 145,195"/>
            <polygon id="arrowRight" class="arrow" points="480,180 455,165 455,195"/>
            <!-- robot, scaled to 0.5x around center (300,180) -->
            <g id="robotGroup" transform="translate(300,180) scale(0.5) translate(-300,-180)">
              <!-- robot body -->
              <rect class="robot-body" x="250" y="120" width="100" height="120" rx="14" />
              <!-- wheels -->
              <rect class="wheel" x="235" y="120" width="14" height="120" rx="3" />
              <rect class="wheel" x="351" y="120" width="14" height="120" rx="3" />
            </g>
            <!-- Front sensor cone: dynamic 40° sector -->
            <path id="sensorCone" class="sensor-cone front-cone" d="M 300 150 L 280 20 A 140 140 0 0 1 320 20 Z" />
            <text id="sensorLabel" class="sensor-label front-label" x="300" y="120" text-anchor="middle" font-size="12" fill="#cdd4ff">&gt;1m</text>
            
            <!-- Left sensor cone: rotated 90° left -->
            <path id="leftSensorCone" class="sensor-cone left-cone" d="M 275 180 L 145 160 A 140 140 0 0 1 145 200 Z" />
            <text id="leftSensorLabel" class="sensor-label left-label" x="150" y="180" text-anchor="end" font-size="12" fill="#cdd4ff">&gt;1m</text>
            
            <!-- Right sensor cone: rotated 90° right -->
            <path id="rightSensorCone" class="sensor-cone right-cone" d="M 325 180 L 455 160 A 140 140 0 0 0 455 200 Z" />
            <text id="rightSensorLabel" class="sensor-label right-label" x="450" y="180" text-anchor="start" font-size="12" fill="#cdd4ff">&gt;1m</text>
            
            <!-- Sensor dots -->
            <circle class="sensor-dot front-sensor" cx="300" cy="150" r="4"/>
            <circle class="sensor-dot left-sensor" cx="275" cy="180" r="4"/>
            <circle class="sensor-dot right-sensor" cx="325" cy="180" r="4"/>
          </svg>
        </div>
      </div>
    </section>

    <!-- SIDEBAR -->
    <aside class="sidebar">
      <div class="panel">
        <h2>What the robot is doing</h2>
        <div class="explain" id="explain">
          Deciding next motion…
        </div>
      </div>
      <div class="panel">
        <h2>State</h2>
        <div class="kv">
          <div class="k">Mode</div><div id="kvMode">AUTO</div>
          <div class="k">Distance</div><div id="kvDistance">—</div>
          <div class="k">Motion</div><div id="kvMotion">stop</div>
          <div class="k">Speed</div><div id="kvSpeed">0.00</div>
          <div class="k">Queued</div><div id="kvQueue">0</div>
          <div class="k">Stuck</div><div id="kvStuck">no</div>
        </div>
      </div>
      <div class="panel">
        <h2>Controls</h2>
        <div class="btns">
          <div class="btn-row space-between">
            <button class="btn-accent" id="btnToggle">⏯ Toggle Manual</button>
            <button class="btn-danger" id="btnStop">⏹ Stop</button>
          </div>
          <div class="btn-row center">
            <button id="btnFwd">⬆ Forward</button>
          </div>
          <div class="btn-row center">
            <button id="btnLeft">⬅ Left</button>
            <button id="btnBack">⬇ Backward</button>
            <button id="btnRight">Right ➡</button>
          </div>
        </div>
      </div>
    </aside>

    <!-- LOGS -->
    <section class="panel logs">
      <h2>Live Log</h2>
      <div class="log-box" id="logBox"></div>
    </section>

    <!-- CONFIGURATION OVERRIDES -->
    <section class="panel controls">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
        <h2 style="margin: 0;">Configuration Overrides</h2>
        <div>
          <button id="btnResetOverrides" class="btn-danger" style="width: auto; padding: 6px 12px; margin-left: 10px;">Reset All</button>
          <button id="btnApplyOverrides" class="btn-success" style="width: auto; padding: 6px 12px;">Apply Changes</button>
        </div>
      </div>

      <div id="overrideStatus" class="status-message" style="margin-top: 12px; font-size: 13px; color: var(--muted);"></div>
      
      <div class="config-grid">
        <!-- Speeds -->
        <div class="config-group">
          <h3>Speeds (0-1)</h3>
          <div class="control-group">
            <label>Forward: <span class="value" id="val-FORWARD_SPD">0.40</span></label>
            <input type="range" min="0.1" max="1" step="0.05" data-key="FORWARD_SPD" class="override-input">
          </div>
          <div class="control-group">
            <label>Turn: <span class="value" id="val-TURN_SPD">0.20</span></label>
            <input type="range" min="0.1" max="1" step="0.05" data-key="TURN_SPD" class="override-input">
          </div>
          <div class="control-group">
            <label>Backward: <span class="value" id="val-BACK_SPD">0.20</span></label>
            <input type="range" min="0.1" max="1" step="0.05" data-key="BACK_SPD" class="override-input">
          </div>
        </div>

        <!-- Distances (cm) -->
        <div class="config-group">
          <h3>Distances (cm)</h3>
          <div class="control-group">
            <label>Stop: <span class="value" id="val-STOP_CM">15</span> cm</label>
            <input type="range" min="5" max="50" step="1" data-key="STOP_CM" class="override-input">
          </div>
          <div class="control-group">
            <label>Clear: <span class="value" id="val-CLEAR_CM">30</span> cm</label>
            <input type="range" min="10" max="100" step="1" data-key="CLEAR_CM" class="override-input">
          </div>
          <div class="control-group">
            <label>Max: <span class="value" id="val-MAX_DISTANCE_M">2.5</span> m</label>
            <input type="range" min="1" max="5" step="0.1" data-key="MAX_DISTANCE_M" class="override-input">
          </div>
        </div>

        <!-- Timing (seconds) -->
        <div class="config-group">
          <h3>Timing (seconds)</h3>
          <div class="control-group">
            <label>Tick: <span class="value" id="val-TICK_S">0.5</span>s</label>
            <input type="range" min="0.1" max="2" step="0.1" data-key="TICK_S" class="override-input">
          </div>
          <div class="control-group">
            <label>Move Tick: <span class="value" id="val-MOVE_TICK_S">0.5</span>s</label>
            <input type="range" min="0.1" max="2" step="0.1" data-key="MOVE_TICK_S" class="override-input">
          </div>
          <div class="control-group">
            <label>Turn Tick: <span class="value" id="val-TURN_TICK_S">0.5</span>s</label>
            <input type="range" min="0.1" max="2" step="0.1" data-key="TURN_TICK_S" class="override-input">
          </div>
        </div>

        <!-- Stuck Detection -->
        <div class="config-group">
          <h3>Stuck Detection</h3>
          <div class="control-group">
            <label>Delta: <span class="value" id="val-STUCK_DELTA_CM">5</span> cm</label>
            <input type="range" min="1" max="20" step="1" data-key="STUCK_DELTA_CM" class="override-input">
          </div>
          <div class="control-group">
            <label>Steps: <span class="value" id="val-STUCK_STEPS">4</span></label>
            <input type="range" min="1" max="10" step="1" data-key="STUCK_STEPS" class="override-input">
          </div>
          <div class="control-group">
            <label>Cooldown: <span class="value" id="val-STUCK_COOLDOWN_STEPS">4</span></label>
            <input type="range" min="1" max="10" step="1" data-key="STUCK_COOLDOWN_STEPS" class="override-input">
          </div>
        </div>

        <!-- Movement -->
        <div class="config-group">
          <h3>Movement</h3>
          <div class="control-group">
            <label>Back Ticks: <span class="value" id="val-BACK_TICKS">3</span></label>
            <input type="range" min="1" max="10" step="1" data-key="BACK_TICKS" class="override-input">
          </div>
          <div class="control-group">
            <label>Nudge Ticks: <span class="value" id="val-NUDGE_TICKS">1</span></label>
            <input type="range" min="1" max="5" step="1" data-key="NUDGE_TICKS" class="override-input">
          </div>
          <div class="control-group">
            <label>Samples/Read: <span class="value" id="val-SAMPLES_PER_READ">3</span></label>
            <input type="range" min="1" max="10" step="1" data-key="SAMPLES_PER_READ" class="override-input">
          </div>
        </div>
      </div>
    </section>
  </main>

  <script>
    // Live data via SSE and control via POST
    const state = {
      mode: 'AUTO',
      distance: null,
      motion: 'stop',
      speed: 0,
      queue: 0,
      stuck: false,
      logFile: 'runlog_YYYYMMDD_HHMMSS.csv',
      uptimeStart: Date.now(),
      enableSSE: (location.protocol !== 'file:')
    };
    const sensor = { cx: 300, cy: 150 };

    const els = {
      modePill: document.getElementById('modePill'),
      cardDistance: document.getElementById('cardDistance'),
      distanceBadge: document.getElementById('distanceBadge'),
      cardMotion: document.getElementById('cardMotion'),
      speedBadge: document.getElementById('speedBadge'),
      cardQueue: document.getElementById('cardQueue'),
      stuckBadge: document.getElementById('stuckBadge'),
      cardLog: document.getElementById('cardLog'),
      uptimeBadge: document.getElementById('uptimeBadge'),
      explain: document.getElementById('explain'),
      kvMode: document.getElementById('kvMode'),
      kvDistance: document.getElementById('kvDistance'),
      kvMotion: document.getElementById('kvMotion'),
      kvSpeed: document.getElementById('kvSpeed'),
      kvQueue: document.getElementById('kvQueue'),
      kvStuck: document.getElementById('kvStuck'),
      logBox: document.getElementById('logBox'),
      arrows: {
        forward: document.getElementById('arrowUp'),
        backward: document.getElementById('arrowDown'),
        left: document.getElementById('arrowLeft'),
        right: document.getElementById('arrowRight'),
      },
      btns: {
        toggle: document.getElementById('btnToggle'),
        fwd: document.getElementById('btnFwd'),
        left: document.getElementById('btnLeft'),
        right: document.getElementById('btnRight'),
        back: document.getElementById('btnBack'),
        stop: document.getElementById('btnStop'),
      }
    };
    

    // Sensor origin (must be defined before any distance updates)
    

    function setMode(mode) {
      state.mode = mode;
      els.modePill.textContent = `Mode: ${mode}`;
      els.kvMode.textContent = mode;
      appendLog(`MODE -> ${mode}`);
      els.explain.textContent = (mode === 'AUTO')
        ? 'Autonomous navigation: evaluating distance and stuck heuristics.'
        : 'Remote control: use buttons or send commands to control the robot.';
      
      // Update button states
      const isRemote = (mode === 'REMOTE');
      els.btns.fwd.disabled = !isRemote;
      els.btns.left.disabled = !isRemote;
      els.btns.right.disabled = !isRemote;
      els.btns.back.disabled = !isRemote;
      els.btns.stop.disabled = false; // Always enable stop
    }

    function setMotion(motion, speed) {
      state.motion = motion;
      state.speed = speed;
      els.cardMotion.textContent = motion;
      els.kvMotion.textContent = motion;
      els.speedBadge.textContent = speed.toFixed(2);
      els.kvSpeed.textContent = speed.toFixed(2);
      updateArrows(motion);
    }

    function setDistance(d) {
      const dist = Number.isFinite(d) ? d : Infinity;
      els.cardDistance.textContent = dist >= 100 ? '>1m' : `${Math.round(dist)} cm`;
      
      // Update the distance badge
      if (dist > 60) {
        els.distanceBadge.textContent = 'SAFE';
        els.distanceBadge.style.color = 'var(--success)';
      } else if (dist > 30) {
        els.distanceBadge.textContent = 'NEAR';
        els.distanceBadge.style.color = 'var(--warning)';
      } else {
        els.distanceBadge.textContent = 'CLOSE';
        els.distanceBadge.style.color = 'var(--warn)';
      }
    }

    function setQueue(n) {
      state.queue = n;
      els.cardQueue.textContent = n;
      els.kvQueue.textContent = n;
    }

    function setStuck(flag) {
      state.stuck = flag;
      els.stuckBadge.textContent = `stuck: ${flag ? 'yes' : 'no'}`;
      els.kvStuck.textContent = flag ? 'yes' : 'no';
      els.stuckBadge.style.color = flag ? 'var(--warn)' : 'var(--muted)';
    }

    function updateUptime() {
      const secs = Math.floor((Date.now() - state.uptimeStart) / 1000);
      const m = Math.floor(secs / 60);
      const s = secs % 60;
      els.uptimeBadge.textContent = `uptime: ${m}m ${s}s`;
    }

    function updateArrows(active) {
      for (const key of Object.keys(els.arrows)) {
        els.arrows[key].classList.toggle('active', key === active);
      }
      if (!['forward', 'backward', 'left', 'right'].includes(active)) {
        for (const key of Object.keys(els.arrows)) {
          els.arrows[key].classList.remove('active');
        }
      }
    }

    function appendLog(line) {
      const time = new Date().toISOString().replace('T',' ').slice(0,19);
      els.logBox.textContent += `[${time}] ${line}\n`;
      els.logBox.scrollTop = els.logBox.scrollHeight;
    }

    async function sendCmd(name) {
      try {
        await fetch('/api/cmd', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name }) });
      } catch {}
    }

    // Controls wired to backend
    els.btns.toggle.onclick = () => {
      const newMode = state.mode === 'AUTO' ? 'REMOTE' : 'AUTO';
      setMode(newMode);
      sendCmd('toggle');
    };
    
    els.btns.stop.onclick = () => sendCmd('stop');
    els.btns.fwd.onclick = () => sendCmd('forward');
    els.btns.left.onclick = () => sendCmd('left');
    els.btns.right.onclick = () => sendCmd('right');
    els.btns.back.onclick = () => sendCmd('backward');

    // Live stream via SSE
    function connectSSE() {
      if (!state.enableSSE) return;
      let es;
      try {
        es = new EventSource('/events');
      } catch {
        return;
      }
      es.onmessage = (ev) => {
        try {
          const msg = JSON.parse(ev.data);
          const mode = msg.mode || 'AUTO';
          setMode(mode);
          
          // Handle sensor data for front, left, and right sensors
          const distances = {
            front: Infinity,
            left: Infinity,
            right: Infinity
          };
          
          console.log('Raw message data:', msg);
          
          // Update distances from message, with fallbacks for backward compatibility
          if (msg.front_distance_cm !== undefined || msg.distance_cm !== undefined) {
            distances.front = msg.front_distance_cm !== undefined ? 
              msg.front_distance_cm : msg.distance_cm;
            console.log('Front distance set to:', distances.front);
          }
          
          if (msg.left_distance_cm !== undefined) {
            distances.left = msg.left_distance_cm;
            console.log('Left distance set to:', distances.left);
          } else {
            console.log('No left_distance_cm in message, using default');
          }
          
          if (msg.right_distance_cm !== undefined) {
            distances.right = msg.right_distance_cm;
            console.log('Right distance set to:', distances.right);
          } else {
            console.log('No right_distance_cm in message, using default');
          }
          
          // Update all sensor cones with their respective distances
          console.log('Sensor distances:', { front: distances.front, left: distances.left, right: distances.right });
          updateSensorCone(distances.front, 'front');
          updateSensorCone(distances.left, 'left');
          updateSensorCone(distances.right, 'right');
          
          // Also update the main distance display with front sensor
          setDistance(Number.isFinite(distances.front) ? distances.front : Infinity);
          
          setMotion(msg.executed_motion || 'stop', Number(msg.executed_speed || 0));
          setQueue(Number(msg.queue_len || 0));
          setStuck(!!msg.stuck);
          els.explain.textContent = `${mode}: ${msg.notes || ''}`.trim();
          els.cardLog.textContent = msg.log_file || els.cardLog.textContent;
        } catch {}
        updateUptime();
      };
      es.onerror = () => {
        es.close();
        setTimeout(connectSSE, 1500);
      };
    }
    connectSSE();

    // Initialize
    els.cardLog.textContent = state.logFile;
    setMode('AUTO');
    
    // Initialize button states
    els.btns.fwd.disabled = true;
    els.btns.left.disabled = true;
    els.btns.right.disabled = true;
    els.btns.back.disabled = true;
    setMotion('stop', 0.00);
    setDistance(Infinity);
    setQueue(0);
    setStuck(false);
    updateUptime();
    
    // Load current configuration
    async function loadConfig() {
      try {
        const response = await fetch('/api/config');
        if (!response.ok) throw new Error('Failed to load config');
        const data = await response.json();
        
        // Update UI with current values
        Object.entries(data.effective).forEach(([key, value]) => {
          const input = document.querySelector(`.override-input[data-key="${key}"]`);
          const valueSpan = document.getElementById(`val-${key}`);
          if (input && valueSpan) {
            input.value = value;
            const displayValue = key.endsWith('_SPD') ? value.toFixed(2) : 
                             (key.includes('TICK_') ? value.toFixed(1) : value.toFixed(0));
            valueSpan.textContent = displayValue;
          }
        });
        
        // Mark overridden values
        if (data.overrides) {
          Object.keys(data.overrides).forEach(key => {
            const input = document.querySelector(`.override-input[data-key="${key}"]`);
            if (input) input.classList.add('overridden');
          });
        }
        
      } catch (error) {
        console.error('Error loading config:', error);
        showStatus('Failed to load configuration', 'error');
      }
    }
    
    // Handle slider changes
    document.querySelectorAll('.override-input').forEach(input => {
      input.addEventListener('input', (e) => {
        const key = e.target.dataset.key;
        const value = parseFloat(e.target.value);
        const displayValue = key.endsWith('_SPD') ? value.toFixed(2) : 
                           (key.includes('TICK_') ? value.toFixed(1) : value.toFixed(0));
        document.getElementById(`val-${key}`).textContent = displayValue;
        e.target.classList.add('overridden');
      });
    });
    
    // Apply overrides
    async function applyOverrides() {
      const overrides = {};
      document.querySelectorAll('.override-input.overridden').forEach(input => {
        const key = input.dataset.key;
        overrides[key] = parseFloat(input.value);
      });
      
      try {
        const response = await fetch('/api/config', {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ overrides })
        });
        
        if (!response.ok) throw new Error('Failed to apply overrides');
        
        showStatus('Configuration updated successfully', 'success');
        loadConfig(); // Refresh to get any server-side validations
      } catch (error) {
        console.error('Error applying overrides:', error);
        showStatus('Failed to apply overrides', 'error');
      }
    }
    
    // Reset all overrides
    async function resetOverrides() {
      try {
        // First clear the overrides
        const deleteResponse = await fetch('/api/config/overrides', {
          method: 'DELETE',
          headers: { 'Content-Type': 'application/json' }
        });
        
        if (!deleteResponse.ok) throw new Error('Failed to reset overrides');
        
        // Then immediately fetch the updated config
        const configResponse = await fetch('/api/config');
        if (!configResponse.ok) throw new Error('Failed to load config after reset');
        
        const data = await configResponse.json();
        
        // Update the UI with the new values
        Object.entries(data.effective).forEach(([key, value]) => {
          const input = document.querySelector(`.override-input[data-key="${key}"]`);
          const valueSpan = document.getElementById(`val-${key}`);
          if (input && valueSpan) {
            input.value = value;
            const displayValue = key.endsWith('_SPD') ? parseFloat(value).toFixed(2) : 
                             (key.includes('TICK_') ? parseFloat(value).toFixed(1) : Math.round(value).toString());
            valueSpan.textContent = displayValue;
            input.classList.remove('overridden');
          }
        });
        
        showStatus('Configuration reset to defaults', 'success');
      } catch (error) {
        console.error('Error resetting overrides:', error);
        showStatus('Failed to reset overrides', 'error');
        // Try to reload the config anyway
        loadConfig();
      }
    }
    
    // Show status message
    function showStatus(message, type = 'info') {
      const statusEl = document.getElementById('overrideStatus');
      statusEl.textContent = message;
      statusEl.className = 'status-message ' + (type === 'info' ? '' : type);
      if (type !== 'info') {
        setTimeout(() => statusEl.className = 'status-message', 3000);
      }
    }
    
    // Event listeners
    document.getElementById('btnApplyOverrides').addEventListener('click', applyOverrides);
    document.getElementById('btnResetOverrides').addEventListener('click', resetOverrides);
    
    // Initial load
    loadConfig();

    // Sensor cone drawing helpers
    
    function polarToXY(cx, cy, r, angleDeg) {
      const rad = (angleDeg * Math.PI) / 180;
      return { x: cx + r * Math.cos(rad), y: cy + r * Math.sin(rad) };
    }
    function updateSensorCone(distanceCm, coneID = 'front') {
      console.log(`Updating ${coneID} sensor with distance:`, distanceCm);
      // Define sensor configurations
      const sensors = {
        front: { 
          cx: 300, 
          cy: 150, 
          baseAngle: -90, 
          labelId: 'sensorLabel', 
          coneId: 'sensorCone',
          sweepFlag: 1 // Clockwise arc
        },
        left: { 
          cx: 275, 
          cy: 180, 
          baseAngle: 180, 
          labelId: 'leftSensorLabel', 
          coneId: 'leftSensorCone',
          sweepFlag: 0 // Counter-clockwise arc
        },
        right: { 
          cx: 325, 
          cy: 180, 
          baseAngle: 0, 
          labelId: 'rightSensorLabel', 
          coneId: 'rightSensorCone',
          sweepFlag: 1 // Clockwise arc
        }
      };
      
      const sensor = sensors[coneID];
      if (!sensor) return; // Invalid coneID
      
      const maxCm = 100; // 1m
      const isFiniteDistance = Number.isFinite(distanceCm);
      const clamped = isFiniteDistance ? Math.max(0, Math.min(distanceCm, maxCm)) : maxCm;
      const ratio = clamped / maxCm; // 0..1
      const maxR = 140; // pixels at 1m (slightly larger for visibility)
      const r = Math.max(12, maxR * ratio);
      const spread = 20; // 40° total
      
      // Calculate the angles for the arc
      let a1, a2;
      if (coneID === 'left') {
        // For left sensor, we want to draw from bottom to top (180° to 140°)
        a1 = sensor.baseAngle + spread; // 200°
        a2 = sensor.baseAngle - spread; // 140°
      } else {
        // For front and right sensors, draw from left to right
        a1 = sensor.baseAngle - spread;
        a2 = sensor.baseAngle + spread;
      }
      
      const p1 = polarToXY(sensor.cx, sensor.cy, r, a1);
      const p2 = polarToXY(sensor.cx, sensor.cy, r, a2);
      
      // Create the cone path with correct arc direction for each sensor
      let d = `M ${sensor.cx} ${sensor.cy} L ${p1.x} ${p1.y} A ${r} ${r} 0 0 ${sensor.sweepFlag} ${p2.x} ${p2.y} Z`;
      
      const cone = document.getElementById(sensor.coneId);
      const label = document.getElementById(sensor.labelId);
      
      if (!cone || !label) return;
      
      cone.setAttribute('d', d);
      
      // Fallback: if arc bbox is zero (some browsers/flags combos), draw as triangle sector
      try {
        const bb = cone.getBBox();
        if (bb.width === 0 || bb.height === 0) {
          d = `M ${sensor.cx} ${sensor.cy} L ${p1.x} ${p1.y} L ${p2.x} ${p2.y} Z`;
          cone.setAttribute('d', d);
        }
      } catch {}
      
      // Color: green (120) at >1m, to red (0) at 0cm
      const hue = Math.round(120 * ratio);
      const fill = `hsla(${hue}, 80%, 55%, 0.28)`;
      const stroke = `hsla(${hue}, 80%, 55%, 0.75)`;
      cone.setAttribute('fill', fill);
      cone.setAttribute('stroke', stroke);
      cone.setAttribute('stroke-width', '2');
      
      // Update label position and text
      const mid = polarToXY(sensor.cx, sensor.cy, r + 14, sensor.baseAngle);
      label.setAttribute('x', String(mid.x));
      label.setAttribute('y', String(mid.y));
      
      if (!isFiniteDistance || distanceCm >= 100) {
        label.textContent = '>1m';
      } else if (distanceCm >= 10) {
        label.textContent = `${Math.round(distanceCm)} cm`;
      } else {
        label.textContent = `${distanceCm.toFixed(1)} cm`;
      }
    }

    // Force an initial draw of the sensor cones so they're visible even before data
    updateSensorCone(100, 'front');
    updateSensorCone(100, 'left');
    updateSensorCone(100, 'right');
  </script>
  </body>
  </html>


